<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>My Project: kew: a lightweight (and super fast) promise/deferred framework for node.js</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">kew: a lightweight (and super fast) promise/deferred framework for node.js </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>kew</b> is a lightweight promise framework with an aim of providing a base set of functionality similar to that provided by the <a href="https://github.com/kriskowal/q" title="Q">Q library</a>.</p>
<h2>A few answers (for a few questions) </h2>
<p><em>Why'd we write it?</em></p>
<p>During our initial usage of <b>Q</b> we found that it was consuming 80% of the cpu under load (primarily in chained database callbacks). We spent some time looking at patching <b>Q</b> and ultimately found that creating our own lightweight library for server-usage would suit our needs better than figuring out how to make a large cross-platform library more performant on one very specific platform.</p>
<p><em>So this does everything Q does?</em></p>
<p>Nope! <b>Q</b> is still an awesome library and does <em>way</em> more than <b>kew</b>. We support a tiny subset of the <b>Q</b> functionality (the subset that we happen to use in our actual use cases).</p>
<h2>What are Promises? </h2>
<p>At its core, a <em>Promise</em> is a promise to return a value at some point in the future. A <em>Promise</em> represents a value that will be (or may return an error if something goes wrong). <em>Promises</em> heavily reduce the complexity of asynchronous coding in node.js-like environments. Example:</p>
<p>```javascript // assuming the getUrlContent() function exists and retrieves the content of a url var htmlPromise = getUrlContent(myUrl)</p>
<p>// we can then filter that through an http parser (our imaginary parseHtml() function) asynchronously (or maybe synchronously, who knows) var tagsPromise = htmlPromise.then(parseHtml)</p>
<p>// and then filter it through another function (getLinks()) which retrieves only the link tags var linksPromise = tagsPromise.then(getLinks)</p>
<p>// and then parses the actual urls from the links (using parseUrlsFromLinks()) var urlsPromise = linksPromise.then(parseUrlsFromLinks)</p>
<p>// finally, we have a promise that should only provide us with the urls and will run once all the previous steps have ran urlsPromise.then(function (urls) { // do something with the urls }) ```</p>
<h2>How do I use <b>kew</b>? </h2>
<p>As a precursor to all the examples, the following code must be at the top of your page:</p>
<p>```javascript var Q = require('kew') ```</p>
<h3>Convert a literal into a promise</h3>
<p>The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.resolve() or Q.reject()</p>
<p>```javascript // create a promise which passes a value to the next then() call var successPromise = Q.resolve(val)</p>
<p>// create a promise which throws an error to be caught by the next fail() call var failPromise = Q.reject(err) ```</p>
<p>In addition, you can create deferreds which can be used if you need to create a promise but resolve it later:</p>
<p>```javascript // create the deferreds var successDefer = Q.defer() var failDefer = Q.defer()</p>
<p>// resolve or reject the defers in 1 second setTimeout(function () { successDefer.resolve("ok") failDefer.reject(new Error("this failed")) }, 1000)</p>
<p>// extract promises from the deferreds var successPromise = successDefer.promise var failPromise = failDefer.promise ```</p>
<p>If you have a node-style callback (taking an <b>Error</b> as the first parameter and a response as the second), you can call the magic <code>makeNodeResolver()</code> function on a defer to allow the defer to handle the callbacks:</p>
<p>```javascript // create the deferred var defer = Q.defer()</p>
<p>// some node-style function getObjectFromDatabase(myObjectId, defer.makeNodeResolver())</p>
<p>// grab the output defer.promise .then(function (obj) { // successfully retrieved the object }) .fail(function (e) { // failed retrieving the object }) ```</p>
<h3>Handling successful results with <code>.then()</code></h3>
<p>When a promise is resolved, you may call the <code>.then()</code> method to retrieve the value of the promise:</p>
<p>```javascript promise.then(function (result) { // do something with the result here }) ```</p>
<p><code>.then()</code> will in turn return a promise which will return the results of whatever it returns (asynchronously or not), allowing it to be chained indefinitely:</p>
<p>```javascript Q.resolve('a') .then(function (result) { return result + 'b' }) .then(function (result) { return result + 'c' }) .then(function (result) { // result should be 'abc' }) ```</p>
<p>In addition, <code>.then()</code> calls may return promises themselves, allowing for complex nesting of asynchronous calls in a flat manner:</p>
<p>```javascript var htmlPromise = getUrlContent(myUrl)</p>
<p>var tagsPromise = htmlPromise.then(function (html) { if (!validHtml(html)) throw new Error("Invalid HTML")</p>
<p>// pretend that parseHtml() returns a promise and is asynchronous return parseHtml(html) }) ```</p>
<h3>Handling errors with <code>.fail()</code></h3>
<p>If a promise is rejected for some reason, you may handle the failure case with the <code>.fail()</code> function:</p>
<p>```javascript getObjectPromise .fail(function (e) { console.error("Failed to retrieve object", e) }) ```</p>
<p>Like <code>.then()</code>, <code>.fail()</code> also returns a promise. If the <code>.fail()</code> call does not throw an error, it will pass the return value of the <code>.fail()</code> handler to any <code>.then()</code> calls chained to it:</p>
<p>```javascript getObjectPromise .fail(function (e) { return retryGetObject(objId) }) .then(function (obj) { // yay, we received an object }) .fail(function (e) { // the retry failed :( console.error("Retrieving the object '" + objId + "' failed") }) }) ```</p>
<p>If you've reached the end of your promise chain, you may call <code>.end()</code> which signifies that the promise chain is ended and any errors should be thrown in whatever scope the code is currently in:</p>
<p>```javascript getObjectPromise // this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous .end() ```</p>
<h3><code>.fin()</code> when things are finished</h3>
<p>You may attach a handler to a promise which will be ran regardless of whether the promise was resolved or rejected (but will only run upon completion). This is useful in the cases where you may have set up resources to run a request and wish to tear them down afterwards. <code>.fin()</code> will return the promise it is called upon:</p>
<p>```javascript var connection = db.connect()</p>
<p>var itemPromise = db.getItem(itemId) .fin(function () { db.close() }) ```</p>
<h2>Other utility methods </h2>
<h3><code>.all()</code> for many things</h3>
<p>If you're waiting for multiple promises to return, you may pass them (mixed in with literals if you desire) into <code>.all()</code> which will create a promise that resolves successfully with an array of the results of the promises:</p>
<p>```javascript var promises = [] promises.push(getUrlContent(url1)) promises.push(getUrlContent(url2)) promises.push(getUrlContent(url3))</p>
<p>Q.all(promises) .then(function (content) { // content[0] === content for url 1 // content[1] === content for url 2 // content[2] === content for url 3 }) ```</p>
<p>If any of the promises fail, Q.all will fail as well (so make sure to guard your promises with a <code>.fail()</code> call beforehand if you don't care whether they succeed or not):</p>
<p>```javascript var promises = [] promises.push(getUrlContent(url1)) promises.push(getUrlContent(url2)) promises.push(getUrlContent(url3))</p>
<p>Q.all(promises) .fail(function (e) { console.log("Failed retrieving a url", e) }) ```</p>
<h3><code>.delay()</code> for future promises</h3>
<p>If you need a little bit of delay (such as retrying a method call to a service that is "eventually consistent") before doing something else, <code>Q.delay()</code> is your friend:</p>
<p>```javascript getUrlContent(url1) .fail(function () { // Retry again after 200 milisseconds return Q.delay(200).then(function () { return getUrlContent(url1) }) }) ```</p>
<p>If two arguments are passed, the first will be used as the return value, and the second will be the delay in milliseconds.</p>
<p>```javascript Q.delay(obj, 20).then(function (result) { console.log(result) // logs <code>obj</code> after 20ms }) ```</p>
<h3><code>.fcall()</code> for delaying a function invocation until the next tick:</h3>
<p>```javascript // Assume someFn() is a synchronous 2 argument function you want to delay. Q.fcall(someFn, arg1, arg2) .then(function (result) { console.log('someFn(' + arg1 + ', ' + arg2 + ') = ' + result) }) ```</p>
<p>You can also use <code>Q.fcall()</code> with functions that return promises.</p>
<h3><code>.nfcall()</code> for Node.js callbacks</h3>
<p><code>Q.nfcall()</code> can be used to convert node-style callbacks into promises:</p>
<p>```javascript Q.nfcall(fs.writeFile, '/tmp/myFile', 'content') .then(function () { console.log('File written successfully') }) .fail(function (err) { console.log('Failed to write file', err) }) ```</p>
<h2>Contributing </h2>
<p>Questions, comments, bug reports, and pull requests are all welcome. Submit them at <a href="https://github.com/Obvious/kew/">the project on GitHub</a>.</p>
<p>Bug reports that include steps-to-reproduce (including code) are the best. Even better, make them in the form of pull requests that update the test suite. Thanks!</p>
<h2>Author </h2>
<p><a href="https://github.com/azulus">Jeremy Stanley</a> supported by <a href="http://obvious.com/">The Obvious Corporation</a>.</p>
<h2>License </h2>
<p>Copyright 2013 <a href="http://obvious.com/">The Obvious Corporation</a>.</p>
<p>Licensed under the Apache License, Version 2.0. See the top-level file <code>LICENSE.TXT</code> and (<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 29 2015 21:00:58 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>My Project: Memoize</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Memoize </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Complete memoize/cache solution for JavaScript</h2>
<p><em>Originally derived from <a href="https://github.com/medikoo/es5-ext">es5-ext</a> package.</em></p>
<p>Memoization is best technique to save on memory or CPU cycles when we deal with repeated operations. For detailed insight see: <a href="http://en.wikipedia.org/wiki/Memoization">http://en.wikipedia.org/wiki/Memoization</a></p>
<h3>Features</h3>
<ul>
<li>Works with any type of function arguments – <b>no serialization is needed</b></li>
<li>Works with <a href="#arguments-length">__any length of function arguments__</a>. Length can be set as fixed or dynamic.</li>
<li>One of the <a href="#benchmarks">__fastest__</a> available solutions.</li>
<li>Support for <a href="#memoizing-asynchronous-functions">__asynchronous functions__</a></li>
<li><a href="#primitive-mode">__Primitive mode__</a> which assures fast performance when arguments are conversible to strings.</li>
<li><a href="#weak-map">__WeakMap based mode__</a> for garbage collection friendly configuration</li>
<li>Can be configured <a href="#memoizing-a-method">__for methods__</a> (when <code>this</code> counts in)</li>
<li>Cache <a href="#manual-clean-up">__can be cleared manually__</a> or <a href="#expire-cache-after-given-period-of-time">__after specified timeout__</a></li>
<li>Cache size can be __<a href="#limiting-cache-size">limited on LRU basis</a>__</li>
<li>Optionally <a href="#resolvers">__accepts resolvers__</a> that normalize function arguments before passing them to underlying function.</li>
<li>Optional <a href="#reference-counter">__reference counter mode__</a>, that allows more sophisticated cache management</li>
<li><a href="#profiling--statistics">__Profile tool__</a> that provides valuable usage statistics</li>
<li>Covered by <a href="#tests-">__over 500 unit tests__</a></li>
</ul>
<h3>Installation</h3>
<p>In your project path — <b>note the two <code>e</code>'s in <code>memoizee</code>:</b> </p><pre class="fragment">$ npm install memoizee
</pre><p>_<code>memoize</code> name was already taken, therefore project is published as <code>memoizee</code> on NPM._</p>
<p>To port it to <a class="el" href="namespace_browser.html">Browser</a> or any other (non CJS) environment, use your favorite CJS bundler. No favorite yet? Try: <a href="http://browserify.org/">Browserify</a>, <a href="https://github.com/medikoo/modules-webmake">Webmake</a> or <a href="http://webpack.github.io/">Webpack</a></p>
<h3>Usage</h3>
<p>```javascript var memoize = require('memoizee');</p>
<p>var fn = function (one, two, three) { /* ... */ };</p>
<p>memoized = memoize(fn);</p>
<p>memoized('foo', 3, 'bar'); memoized('foo', 3, 'bar'); // Cache hit ```</p>
<h3>Configuration</h3>
<p>All below options can be applied in any combination</p>
<h4>Arguments length</h4>
<p>By default fixed number of arguments that function take is assumed (it's read from function's <code>length</code> property) this can be overridden:</p>
<p>```javascript memoized = memoize(fn, { length: 2 });</p>
<p>memoized('foo'); // Assumed: 'foo', undefined memoized('foo', undefined); // Cache hit</p>
<p>memoized('foo', 3, {}); // Third argument is ignored (but passed to underlying function) memoized('foo', 3, 13); // Cache hit ```</p>
<p>Dynamic <em>length</em> behavior can be forced by setting <em>length</em> to <code>false</code>, that means memoize will work with any number of arguments.</p>
<p>```javascript memoized = memoize(fn, { length: false });</p>
<p>memoized('foo'); memoized('foo'); // Cache hit memoized('foo', undefined); memoized('foo', undefined); // Cache hit</p>
<p>memoized('foo', 3, {}); memoized('foo', 3, 13); memoized('foo', 3, 13); // Cache hit ```</p>
<h4>Primitive mode</h4>
<p>If we work with large result sets, or memoize hot functions, default mode may not perform as fast as we expect. In that case it's good to run memoization in <em>primitive</em> mode. To provide fast access, results are saved in hash instead of an array. Generated hash ids are result of arguments to string convertion. <b>Mind that this mode will work correctly only if stringified arguments produce unique strings.</b></p>
<p>```javascript memoized = memoize(fn, { primitive: true });</p>
<p>memoized('/path/one'); memoized('/path/one'); // Cache hit ```</p>
<h4>Resolvers</h4>
<p>When we're expecting arguments of certain type it's good to coerce them before doing memoization. We can do that by passing additional resolvers array:</p>
<p>```javascript memoized = memoize(fn, { length: 2, resolvers: [String, Boolean] });</p>
<p>memoized(12, [1,2,3].length); memoized("12", true); // Cache hit memoized({ toString: function () { return "12"; } }, {}); // Cache hit ```</p>
<p><b>Note. If your arguments are collections (arrays or hashes) that you want to memoize by content (not by self objects), you need to cast them to strings</b>, for it's best to just use <a href="#primitive-mode">primitive mode</a>. Arrays have standard string representation and work with primitive mode out of a box, for hashes you need to define <code>toString</code> method, that will produce unique string descriptions, or rely on <code>JSON.stringify</code>.</p>
<p>Similarly <b>if you want to memoize functions by their code representation not by their objects, you should use primitive mode</b>.</p>
<h4>Memoizing asynchronous functions</h4>
<p>With <em>async</em> option we indicate that we memoize asynchronous function. Operations that result with an error are not cached.</p>
<p>```javascript afn = function (a, b, cb) { setTimeout(function () { cb(null, a + b); }, 200); }; memoized = memoize(afn, { async: true });</p>
<p>memoized(3, 7, function (err, res) { memoized(3, 7, function (err, res) { // Cache hit }); });</p>
<p>memoized(3, 7, function (err, res) { // Cache hit }); ```</p>
<h4>Memoizing a methods</h4>
<p>When we are defining a prototype, we may want to define method that will memoize it's results in relation to each instance. Basic way to obtain that would be:</p>
<p>```javascript var Foo = function () { this.bar = memoize(this.bar.bind(this), { someOption: true }); // ... constructor logic }; Foo.prototype.bar = function () { // ... method logic }; ```</p>
<p>There's a lazy methods descriptor generator provided:</p>
<p>```javascript var d = require('d'); var memoizeMethods = require('memoizee/methods');</p>
<p>var Foo = function () { // ... constructor logic }; Object.defineProperties(Foo.prototype, memoizeMethods({ bar: d(function () { // ... method logic }, { someOption: true }) })); ```</p>
<h4>WeakMap based configurations</h4>
<p>In that case memoization cache is not bound to memoized function (which we may want to keep forever), but to objects for which given results were generated.</p>
<p>This mode works only for functions of which first argument is expected to be an object. It can be combined with other options mentioned across documentation. However due to WeakMap specificity global clear is not possible with <a href="#registering-dispose-callback">dispose callback</a> registered.</p>
<p>```javascript var memoize = require('memoizee/weak');</p>
<p>var memoized = memoize(function (obj) { return Object.keys(obj); });</p>
<p>var obj = { foo: true, bar: false }; memoized(obj); memoized(obj); // Cache hit ```</p>
<h4>Cache handling</h4>
<h5>Manual clean up:</h5>
<p>Delete data for particular call.</p>
<p>```javascript memoized.delete('foo', true); ```</p>
<p>Arguments passed to <code>delete</code> are treated with same rules as input arguments passed to function</p>
<p>Clear all cached data:</p>
<p>```javascript memoized.clear(); ```</p>
<h5>Expire cache after given period of time</h5>
<p>With <em>maxAge</em> option we can ensure that cache for given call is cleared after predefined period of time (in milliseconds)</p>
<p>```javascript memoized = memoize(fn, { maxAge: 1000 }); // 1 second</p>
<p>memoized('foo', 3); memoized('foo', 3); // Cache hit setTimeout(function () { memoized('foo', 3); // No longer in cache, re-executed memoized('foo', 3); // Cache hit }, 2000); ```</p>
<p>Additionally we may ask to <em>pre-fetch</em> in a background a value that is about to expire. <em>Pre-fetch</em> is invoked only if value is accessed close to its expiry date. By default it needs to be within at least 33% of <em>maxAge</em> timespan before expire:</p>
<p>```javascript memoized = memoize(fn, { maxAge: 1000, preFetch: true }); // Defaults to 0.33</p>
<p>memoized('foo', 3); memoized('foo', 3); // Cache hit</p>
<p>setTimeout(function () { memoized('foo', 3); // Cache hit }, 500);</p>
<p>setTimeout(function () { memoized('foo', 3); // Cache hit, silently pre-fetched in next tick }, 800);</p>
<p>setTimeout(function () { memoized('foo', 3); // Cache hit }, 1300); ```</p>
<p><em>Pre-fetch</em> timespan can be customized:</p>
<p>```javascript memoized = memoize(fn, { maxAge: 1000, preFetch: 0.6 });</p>
<p>memoized('foo', 3); memoized('foo', 3); // Cache hit</p>
<p>setTimeout(function () { memoized('foo', 3); // Cache hit, silently pre-fetched in next tick }, 500);</p>
<p>setTimeout(function () { memoized('foo', 3); // Cache hit }, 1300); ```</p>
<p><em>Thanks <a href="https://github.com/puzrin"></a> for helpful suggestions concerning this functionality</em></p>
<h5>Reference counter</h5>
<p>We can track number of references returned from cache, and manually delete them. When last reference is cleared, cache is purged automatically:</p>
<p>```javascript memoized = memoize(fn, { refCounter: true });</p>
<p>memoized('foo', 3); // refs: 1 memoized('foo', 3); // Cache hit, refs: 2 memoized('foo', 3); // Cache hit, refs: 3 memoized.deleteRef('foo', 3); // refs: 2 memoized.deleteRef('foo', 3); // refs: 1 memoized.deleteRef('foo', 3); // refs: 0, Cache purged for 'foo', 3 memoized('foo', 3); // Re-executed, refs: 1 ```</p>
<h5>Limiting cache size</h5>
<p>With <em>max</em> option you can limit cache size, it's backed with <a href="http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">LRU algorithm</a>, provided by low-level <a href="https://github.com/medikoo/lru-queue">lru-queue</a> utility</p>
<p>```javascript memoized = memoize(fn, { max: 2 });</p>
<p>memoized('foo', 3); memoized('bar', 7); memoized('foo', 3); // Cache hit memoized('bar', 7); // Cache hit memoized('lorem', 11); // Cache cleared for 'foo', 3 memoized('bar', 7); // Cache hit memoized('foo', 3); // Re-executed, Cache cleared for 'lorem', 11 memoized('lorem', 11); // Re-executed, Cache cleared for 'bar', 7 memoized('foo', 3); // Cache hit memoized('bar', 7); // Re-executed, Cache cleared for 'lorem', 11 ```</p>
<h5>Registering dispose callback</h5>
<p>You can register callback that is called on each value being removed from cache:</p>
<p>```javascript memoized = memoize(fn, { dispose: function (value) { /*…*/ } });</p>
<p>var foo3 = memoized('foo', 3); var bar7 = memoized('bar', 7); memoized.clear('foo', 3); // Dispose called with foo3 value memoized.clear('bar', 7); // Dispose called with bar7 value ```</p>
<h3>Benchmarks</h3>
<p>Simple benchmark tests can be found in <em>benchmark</em> folder. Currently it's just plain simple calculation of fibonacci sequences. To run it you need to install other test candidates: </p><pre class="fragment">$ npm install underscore lodash lru-cache
</pre><p>Example output taken under Node v0.8.26 on 2008 MBP Pro:</p>
<p>``` Fibonacci 3000 x10:</p>
<p>1: 25ms Memoizee (primitive mode) 2: 28ms Underscore 3: 34ms lru-cache LRU (max: 1000) 4: 65ms Lo-dash 5: 94ms Memoizee (primitive mode) LRU (max: 1000) 6: 262ms Memoizee (object mode) LRU (max: 1000) 7: 280ms Memoizee (object mode) ```</p>
<h3>Profiling &amp; Statistics</h3>
<p>If you want to make sure how much you benefit from memoization or just check if memoization works as expected, loading profile module will give access to all valuable information.</p>
<p><b>Module needs to be imported before any memoization (that we want to track) is configured. Mind also that running profile module affects performance, it's best not to use it in production environment</b></p>
<p>```javascript var memProfile = require('memoizee/profile'); ```</p>
<p>Access statistics at any time:</p>
<p>```javascript memProfile.statistics; // Statistcs accessible for programmatical use console.log(memProfile.log()); // Output statistics data in readable form ```</p>
<p>Example console output:</p>
<h2>``` </h2>
<p>Memoize statistics:</p>
<p>Init Cache Cache Source location 11604 35682 75.46 (all) 2112 19901 90.41 at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:276:12 2108 9087 81.17 at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:293:10 6687 2772 29.31 at /Users/medikoo/Projects/_packages/next/lib/fs/watch.js:125:9 </p><h2>697 3922 84.91 at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:277:15 </h2>
<p>```</p>
<ul>
<li><em>Init</em> – Initial hits</li>
<li><em>Cache</em> – Cache hits</li>
<li>_Cache_ – What's the percentage of cache hits (of all function calls)</li>
<li><em>Source location</em> – Where in the source code given memoization was initialized</li>
</ul>
<h3>Tests <a href="https://travis-ci.org/medikoo/memoize">![Build Status](https://travis-ci.org/medikoo/memoize.svg)</a></h3>
<pre class="fragment">$ npm test
</pre><h3>Contributors</h3>
<ul>
<li><a href="https://github.com/puzrin"></a> (Vitaly Puzrin)<ul>
<li>Proposal and help with coining right <em>pre-fetch</em> logic for <a href="https://github.com/medikoo/memoize#expire-cache-after-given-period-of-time">_maxAge_</a> variant </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 29 2015 21:01:00 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
